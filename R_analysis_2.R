gAAAAABikz-_O7cvEegAdbSeRsFhB7GG5HaCGdbwU7O-A5pXvpEbo5D8D_LuR_0anZ_iwqkJTyRdc1VvvWvG0IxOPvVMCipTGzg7gtpCh-sTM9HxJtYAHyUKALS97-yOOJlLBbllr7Q8LQfCGcx2HSC-phH82lrUOIGnBKAkLB75LERcAgPxS2HKX-vRNY5dBrD8rslLU7G_y_CUXyX-40t2-i-0zpGIa2HNxjDtQ8GWtLuQ1J0TkMyYTsk40V9T5Yn8h5hxJLZhAtmqJKBSxP2FveQI5rSKNHZZ6j3LFzR7IyNWCBm4C99U4AmD_HfWHcnWQ14GDiQZNLrWniKgYdh-_6a3JSIiFju0fnU5xZEHGgo6XzWkhf9eQJoNHFp_MQDvWrTQ5Y81vSArQYaS1GHsLFWym-40z5Sj09X62ETYFjF1o5kxc3VuV5X_fomGNUSKiEEqYN_fzNeXpKV6mCFRL1QxojV_DPE0eDAw3MMu-Exxarhp9GoHDjnAccSiMSPP85Ha2rNMrhBQtjkHiUqsOqb7b7X1NspxLjrnZuonifenvXCi1UUNq7p3x_6kmaLmEqTE6ODYz3aKWjVbkqbplFmTFi9jkjIFkDwEeHAd91Y4PRPNtHpzbjVzGGJnNzOEUt0wL1gjxkRqJ210LFTc2wx6FUehPQI-RZqWI-gjABPluDcdB7NylxKbBdvwY0e848IL_wojnWjLu2vsHp-h0YVVMZWHlAkSjHb8YH0cOavpVy13lwA-JhvaP_G6cfAkgCvy-wDMN1-CzOmEdWcXg9NB06dfvP6Rj6ipAn0VJ1R9Pu46Mutxf4sY6x4ln_sLGKcBUPINtic00mmuOZZcgqHb0u7r4vin3evk7FjRFUOjnT3trlv9FtLNc8qq6xFv4Nq54_67x4SIm61SMfei2Uhd1sNF4dX0CR6zyTo-rmXUpAZWBDi0lHHqyXxk_ZHmDzUVRXWMbI-iFLzzJaw_9SMOlPbKIJBHA81hjo6thGdmeVH4qVIcq4rk_twmMkWHwXIR2S4WeLy_kbxR5HiqWLKjeKJTvNCsj3SDLwX2U-WHIKNr5oKUoqbkEqHZQSt0mc--XqreNX22KxdgiD9EOOQEGQh9xU94lS1ZoS4V-PZr7-sa0R9rZaswOv9AKnCLxnB9aq17UfubM5KzWBjnWU8_-CgvJ8ENehD5MkcGl7tytwlmZKaIpxc9Nd-FrMK8-UMajR_aSySeosK5hAtfY5u3QW6NZoLerD8NKGsdAMUxeU5tO6TWH5TQJKs87DwBeCeJ3ZFKO4RHQMtOUgczZHS6XLtUKI-Tc2Dp4jk0VT7ds3KUzHiUOnyG_02MtukCrjtbHhnCm4djAKzk_WRuh-uoo4pXyM-aiqcItSrMQeBdfIZhMbhoVFgbADJkq40sCrwoOkpCdLXYptBxxev2JQJZLqSZASy7IedZn_wXAzN4bYnUhoJyP-mK3HWEjvznxA0BpxpSbpbHCr8kjb6Xq_5W346DH8dFNpgBBBshCOU_J74jtbheXUcw_E1uGx2Lfpg3o4VJwo4YoHKvBiLVjDrLBLegj-_OsrSFigC0IEOlVVEubQV9WnkYigqeqNN2O2MQ8tZH-77m43MJ6M6H8ecb0a-LiCIaRSSlQmrOKV-IbviL8TgeXUqzTOwMHcDQuY6zC0Lp3_8h90hYM6JLeOxlXr03t3ZE4HpdJpLjcUpFBE7SNEZmHSgn-2LOM1UXpWoXfJfo4rP2YADZ7BfuQzrpTqerpaZ2-lLBpc4wb05f2KMC1Xml4UgoHPs4b8YcHaB0Wn0r5R_NOKj6aV_o6ij2bKPLhlJGq_2TwOqmkr27JHjoi2oka-g9qxpjxNHnqxMHh17-lSOAG9jc3MYTMY3KjHGdWZVkZeJZ9_e3jlhBK3NjFyz7zk8F5ienmlp_xAwVSh5FG87oXsuSI22hnebZh3RAKZMbpBHGBdnWooBRmnc1PmxjFV52wKL6KmYcEYk0y8koozHaUhI_NHfps8iQGzKmhfdCquqxNlvCwGqPTEU3878F3KX2dcuPEx9rJ-_klUHIdKwYyqD11FcnYxISi9LO8XUdNTyE8mdO8IQWbxdvwdkuk4l-5670NycdNDMwC4NoJQd7hygnjA9mOIMGnafA2pJLIbvjDHAyFzgvEcIphcXpVjNSLV1LHTJ18Ctd0AQdHZY4IIVGz7Bzu_jnCVsQeG_dqFDaEr4mYiCMEXUOKTE0UXrJuy8OFvnzMbvg5MQWsJEX8QSn33dWYMmxJpRTdygAUEKJYPkQ_XrL4nsiatUoZZKoz19RsrYXTtUI-pfGtYN2GCwjamgSZ82Zzy5skwuhKqbCE8AjZ8QqjBL5gLTxgd0jVbd0xmiT3YiJSqrsD4HMo_wAiSVrJglQhUzijxAU_lblxjlkfOzw_NeivoRpI3dgMQOP8B8GWrKYjtFptynVIviE2gVy6f3iLEnKDfvk5gYE0Ti8WDj9aub7SimjZRc-bIJD32J-CgVAsdWJJMHV-ZEY8LTRzyggYHK9SuVolSU77jEtxgoZCC3nWmTae-3Vk9U8BrTQygK_ZWIy5TxukUDKjpd5WIy5z4xNhJ-O8PFWuF_COjhgPRzcLoitq3xRxbK-HPgSr5aH2dARg9J77RmWAK3bz_k5FVcWlzmjncWf_eGguwxY-NRMF-MnikwfCv9vxbNIPr1NeAsk7uT2-uAaqAiLk33Fnti4XMAoE5FZj4x38qZFmcRZBeza6uxrsXrjCn3ctnSTGyCxAgXKzG9lACEFAPYeuY3w3XuiCpfAeVb4E2-hU9kgkzu_lg6GzqwWE_kdSHnphqIKoyQqfGXNI70cTMxuDfszBUSs0kAtFm-l1UwY54MNewGpt50-4z1fzGupDMCRdz0G4CVWbu3v4U_orwKfNbQnWbGckhSWrdiNgV5GD4cTAK3XCaGzAmtV3ZCm9tORy9ZDX5sUNwwxLt5q15jauKMuvy3TVMbiK719Kqn91KjCELapiDIjn3aUwwQgO_Jib1mc2OL-ZX9_XF2Qqj4QEEXNen7rA1mtzTzVcbbZeb60Gk6f9Xb1yLwr2rEldANiDYGDMEJzrgOabyLvB14BRrRnosZeusZW1og4BDdW5ZuoWIlvTdBahEDdhl0pN0KDRW0nKVfPaUKOtYVdeLflGW2E1mvuTRP-PeKuv9ZRpt4xCiPjPBXlqFrxEKvgCpY4gpAn6OdBM64z0VkMqzBrgGRkuZWa6Fr61-funOp4rA4nyxLCNMBPd_mlgxcZaZBC4mN0PL1BHpnEwN8KKH5L8jLvRVL80hxh59czoy9CA7I3RH-tzn0bG9cOydFJrujxEHAnDL-lWHywAKDIeP6V2_fDpXMj4a9UvtuYFsrQbIy5JiTiPT4b5B7YsJWkwJYleSsJOkJvmvn00NZ5Yz4XZTjxcXQK3oeg-Crhl5_LxHMsYd3oECQoagasR0VafKEBF1ai7E2mWxgnwL29b_yt-k9Y71DNarWtoG1W8D2QxIXptuTqYgPOFQXtQWmi8RHYPyHRJjW40rFCibMfOMR8kbevsy9t4xsUFsAfKNP20xIB_Gm-Gdo3h5Q84g5o1a4z9XREkmPH15ViAFaGy6CvpmMRe7t3pwkuCnrAGqbL379G_z2bpYt1Vn3hUqU1uhVj6LJVx3MGfjP10gDWrFrE_KbAn4ByTAzK-TFjP3LqVmTFMP5_ahr3v5bX1rmLtO8avt4tsSjDsXHrynI3OxSVXd-8IBNiGejwL7lRtoCUj2APUclxPUl5OPrmPy0hbO1B6FOzl227lMGrdBC08MuEMw-kCvAFNTrdvaP-clNsCdEh-fFFr1tyMPVtWqrnE9EZFfAe5AuYIxbHfnzLCapww4TyF423AYAihGkYH1xxqC7lihgAvpmS9sbA6XFbey8z8WuiqX03gYBWJBRwDF77vxtAbP7LwLKVpIjPfWG93TbvbT0Mo3YTbEmcLhJFrn5SAG9yuU-norIfNKrqDNZeb-M4EbqzipQOYfFFideQk8iSZv5pXw_laiOgM4mXzA5nLaqINkDdRbkbDM4Qh2xlc2t2erQc4UTQy4QjBhsyo2xMJa9nNaBmBD8Wg3ruUmGxJ36kKxQteWtNvOXmTKtFKP5P2EEHUN5DuKAIS4mAg5vTW42GcWZ_vtaeln2gSMqwr8KXaOEJYXB71oVmgXHi21Hbq7D9QqjX47-xB07_XmFs1NNs1ovK5qy8ge0WXGarDWnMlc8_A50nfEfyl7QtT217qvNgV1KGs0w2dKvJP7y8S1p9fXzgDRUpuk3YB4UcUVMzJQT5gtiX-bNEhhB8wkrDkbnV5IGu7nv-qrLp0jgcaX3Zsd6o2shfrzDErvAlm0Gj44SkcaGMjABkB1sJqWOFmSDMFf3aHG5aha3tAiDYopDYBOD6k9OR_RljTfUP35iFMaHIqY1y9BsOlA9khZ9wKMnF_4cghnHhjt38AFBvrpr2sTTp874uOIXr9LhLStEsZ_CJmFaRSicf68J_ko7RDRi9q2zECtvaQ7U4JVdYAbHkQw7OTVc9TQIKR-AtCmZXD50Hv_DXZzaH3gTVe9HQqPSu8zc3n8vl_4uYqIwPZEx_8H-d7wM-p13wwHWLNk3i9zBQNGl7Bl-JMSaqsQg7_ZjBm3KIdAc8acYrr6s17SkMMgQFjfnvPxaxXDHeJNLttUxwgMKbrtcQ6R1OG3M6zJgZfAa-36Ng2sBup77ytUR3R-Ydex3WBDyyzuo2hhIZ1n8JUugdORWHhNoYR9Kf3lBP89BZmBodbkJ213E-I-IUiODB4HCAZl-KBOAhp7LXVkScEkBjhdOqWXUSIm9uwqtTWc2JLNfjWUYH1XzpGuk2UIsj-fei1PUOG_gXqsNd_GBnR5uvXkHRkcK-ksfjfs_TemCSCVjnnXOKeyjL7cbHarTwiQ3XMIcRnNpMm47uyuB_47XQo5BHpfkN3mAsVqv-B5TqEuLr6X4hW1LhrE5HE83Xcm9dHpXhBOzR2TiivIhj-_HqfztOVg91DetNoFAFSLR-WZuFKT3PC3MpjB3gmBnVIHjLUyyIoTCxwq4E6btgqJc2opkpsKopwElMdHkwiVM8KhFHid2YbM7fx4KZqAQteRKqMb17bMxnNV_K-kMQ_G8Lp4hClEXfmrLBrW1XZn6zXbD_YCgdU0qSP4o8zS3x46FFjW2rZGqFWCFz7WYaR3IrUmqBlfqhxQaqOwWyRsaACpnBfn9WnsyqsSkYfsKx7bc1LbnM9BKTl73mnVYnIIwlZPwfDrOsCGCYOYGpej2lgQFml7CnkjSg6sByoUyeUeo2Jxz23lIthrCYCYbyBhQ_nfEDULivyORKrQQ8omC3zaMydOETHbE4wFgsWOz5l28e2LgXC1LAulI3YOtYiz-mfRp3nxgYGYBvt__vG3_N01bC04O1mqnS3yeQVDB3IY19e36IeTcyQBfZ3zLyzjfGZLa71GgiICZQtuZ2iZ6jJLlUgALMqq8wjNLf03A_PIKSb0NQGb3t-FEHxQa3U0hKi8a8LuAip4XaDd0QOETsQ6gdMV0af9XqTnDWm1IdRVWrP-QY2C01MYhXVZ9UT1YJPVnO6EP97TX_wCrsO7EWPeaV51e73qsTxnLm_XGjQs1qqcEcket3xAGWoa02uthLi-mOUuxjpUo9yz3UVhrFuVz0txztRwpt_T_s6u_x3FgUbc2E6UCSAAtbifW6Wabn5hGZF70u9xaF2iRTpOf1Ky5BjdP0f3hFCAnIPwk0dNNptjpBnd6SEyvRhnzlAsul4MGMTkwMiJm0nx3NsXHVQXDwRGM2Z1f5rN6jmi125OdaYyHfp0VJhomUweFZ2IFYVjHOKx6Izp3C_emqPaJVGdqiNEDKZ-vjhWW35fcHRfjYPaafuIhuYbTfHnjw296z9LFCEEro4NcqTSZkZrdAYF_v4BMhKNmyeHFizyOuwRn60erjyThOurFKIvjfMEMGwGH2WSypSMzYe2FsQL_7bnRhFx1sAAut2dt0udvd-Jn4HmMF88HM3kP1oYH2SvJYjuVMcoMyE5w9aWRF6p9HSr1FBQ2ONdsS35uZsHklU1m-Zsu7VGIMOMK_Og_mFLS9wMSYyHxvAT0nIjRfe3hiqkhGAuo-kAAC-ZyKhOBoLPttDZnc_qHIkNA_ZEFVLueNvTnSCNFzrxW1kcq6xV2UFLEaKfpuFDuMIEVjCQJzDVMP7YPMM--mOqBXMGulUwxxullwG-fJpTUlh6uKKVihMenuiE-X5RZjtKevQNon2q5XxGShHQ1xBhbETNFq0w6XqJjJAtxwYnWIcerGq-rCP9OGz3LJ_eRTxBIyWDsfVBLxAJwMDwC_1jOtRDmCmlRH54W_NJJIWSYP5yNC0VfQbLr0wdFpruwbHNkTkrM999Dv18X2BDgOH1mrr2TeUgyzkxKWGDLzgIKee7KImAQttQ9A-KbeKNk1aYtcJhVCgfldS58mMhyGK7fOOnD3igpf_uzsQjjj-xmzvGSY_7nhNAfLY6P3I6RU5q1UpEaz3dV2xT2bEkSY6f9uogIeOqqnabZ5UheMaGyG_kuQK4nfZD9vypVVHJhe5H3vnosMyZPrT6MzNFkzNPsz6lUuUeMYMg-3z6yJl_pztGZZTj1mJNlj4U1Lo9cet3RB1jJjKpWv5i9244_2JU-RSkIvXtoYKeGqSHsSLV5FmteYtdsntUjhxPEarNBUFpIhu8V8_Io2c316VyZTlgLbZwj0C432i86pFxAsmQYd-X-9Sc4zGyGDeQK1YXxKgloeFAFR12F52gn2PRU6PruIdbNrkGen-PeV7SSDxwjARvm_DtAL_ccRC8xQJHADQd1foNVZOkFLCJ-3GM5k8Rkqiv6xYkXgyso-DsmwFbvBdq-TiSYGHFZF-gzYg2gI3PdMj6CcKdRwUgYJJaaXPbOJs4YPswN-5etVt0GEuhxJPzQhU_IiYlb8OXC0UcoNVIes4MkWYU44b4ERR7lwZ2JSo4dEotIC7KhOTjqDGuPune9gIG_UOxA3jIiWZEHDVfG5s9LUXVB6JjjBQstuM_pMgoW9WGQMLf3e3XBSZxg_1gomrwxKB1Rwx8tnRVmTZvowD0ERvINXmWEjCo6Dft7GCyDq5pEOu0yHfMlq4coAcT3epO_10-W2JB79vnl-2-KFfbRS6j7Q9KOdFsuJQ2yPojUmKfF4O6_mg5q1bKp9Z5WN_KLYiYnKgy2wTK1cgVZCaSK5BcJsIhx1KlBulmW41YO0Lnf9Ao04xxbDgG-8GmWItWYkhwaxQKdp-fyC3vLLgKeAZd-HLgOU4OLBvN5lhf22ov915QGf2Y8V8iBMmOQUQbebcxAu_GfGP51CQpVxF6c3oLhb8B9hizbd_ZxFKTrWB36XCBsMsbOOTn5MDtyLa1DRvtI5UbhLEy-OituTcc5n0gUpqq7riKyWLwVEigUdFLgDGdkHyIMdNzPflCp1kJ07SPPb0LKfAMRlb6aSxtxOIxQ98MVo0WwdZBDpNZ-txbzvuSggya1sek76c3hDccLUg-8lcMaOaN46Po0XqE9Vqk4x9rTMpCcmdKAmLIRi10Nt-a9mzZGzQHLCFeMcKf8Iiwxvv9LpflKdyhA4d5JYzJqx0k0-xBNDr1pYoIISjiWekzqHV6Qu7frGnGdK_FmZQKIBftKkjdjMxsy1BIfu3anALPe0wgKJx4Fjp2B2FsV4E2B2PMULssEsmCRzw70PpW8QDayutkkfW50GBYCwrIRHhEiamXM_iaWHVe9GMMeUHwn9gxYfipbBnwtfw_br0zz4KAy5jc71y9R6RqWn3YjTsrVqw5myuxcUTpu6_IV87GE3q5CQVeWmNhpdczZElZZNWnSHnVYlDakYsVBNX6fUIUUrsXD9xIPN9PEwdqdwMBUYmnAKYmB2ZEcQ8sUcOeaRvZsjxwLeBICIGfEYrFbPEgspzgsTY4vPjcM1QK13IVepa4YH-QJoix8f21kwDNSjQAPHgyu1Xsn32kApt1obxMUbad-d_mC85_VmYGb3JoTmJok083tOEOKxZoTaRS-WbeS7OOzvrhkplbuGmUkQZAG38tXwMZagE21IGoQruntFH7BvU6SNsvlLjFRmy0WXPZmBPCMaNBEzKUiR2HBQvfnhwgCdNh94LGyijPU-0gzoy7qIwQjNyW28Oxq8HJtRDNFILN0IbFhjeZZO8uyuCkv1TH8CJt63IR4NbHMcs1wEOM4bVGGYIbl-CElulplnGm_bGRouN4ctTIERMHJmpgRhd-Lkx2sJAe0sjL6429Ub1TDDAJHoJTP5IDzYHe51oZNbHtxcDqUESQAuwooXZax3893LLYIvKXVi2F60c8vCojSm_jLEEeZiiDJgP8MtSGATfa1zIib3LvZy_8lmrgdY6un-gL3jxOUz1l9kDdcBKcxd5ilSdD3XN2Nxqk4knRyU8Wdong_ER2Q_tLK7mlrB4lrzL4bnLNSeAuiHVs_ZNmHTx5DzDhdBZgkXtJ3_-t7PRmBRlDVZXkCdxAiVG1L35AgTeKGu2gEqOC1aZLy5fn4ddFdAUUrCiqy6RWdHhZ6cmM3tlpZo6VlPWJVDM0gM0sXBsCaTa1CkNRabEz3JYD1eZzr_UtnMr9JPGhQyNf6PxOK1YtjAgJv-bPNDJ3s1EdcvKR7b_Z84gFKksUl-QQfKDtLSbDwX3uNO1DcrdiTSZpfQZp5b7Es_WYWMx6nkUtiKQfB15VE6eYKltOuNzMtEUHGSX3ISaAb58i2JEM7L1EPtvJsvRNRQlj3Cb0dZCoidiSPymrrPjPEuVlwfIazq8s7jreDoRfYq5FxwnISKVpamSRrsrs6wLr5TLDXYlsxbQQA3zObxvDdPe0R27MyS4aMli3INyo-maNADyyrIPCdMgC260pYw_kSnaM1zoTOwglcBgABu5MtTD8mGwkiv-ZssVxfLtrIOlkUVl8mV00cXzmUWl89fCqAIVXkyhGS0UlwVNsHTSo3GMsTtOxD1f9_SehuTAgs4x2XNrBfxDoqCpV89CwIE5C-SaZldTRmxu5YohkHsupxh0d0j6I2dQD1zO6IyN-YHCHjV84OqtscGI9XNOuD2mTs_seF5WKNlp7Q00-Myr8C-oKWnuTxlvdGxZqqrL0NLgk-2tMje9X3R_vOyTBuS33I3bUho8qqMd_HV7KtydXX3vMRF7fYnXB7sYaZn_QQKs4Fx7ecLofr3Htno0NnO0RFMrgXolfIj85v4L5rwzOaBAMI2bjXssI2chb0It_7l4YhsOvS_rPfnQmF5zSDdbbfzwtgOPFxDBIFx_a1lLCy0aZv97l4BrMrsQHambZRVojh0V48bWoQdVwFtuE1RwnvvVpT9_8spY6HXItYNVdqToRFxxTR6tJ2W60FrZ6ykHXN-OIS6_IEuUrJFIAHRcNjdJPDy-L47GlS84nc8W56OvA46g-dbA9elam2JcowQ9SfpLRaAWI-pyTV2_dZcDgQ2QNaOKVorOMOgpRg_5cLtHfNpBiYd7TqEVS-AlPNa-yIRs5t2LJ8I_I7MUf1mAe_ZV2IXcWGkrMcuOTAQq7HUq9TNexfbZ7yI8U1hZnRUyjtJg_Vf_9PBUFCp5W4bZqUKHiZ0WrWK5Q_P9vi2W_066P2IwO7vlhjQ3iU35LB2_YO9XDGhx-h50Grl8fLbQYoiSZ3JiS7WhZU2v0nSsI8Hl4p0L3Xht987N3xUKlLQwXZeZJnDQCejnpXOqsYrrPhKrgHTmTY7vbJLuLwCQFXVfIMy1CbOc60Cg8UI9pd5suw3dx9Cf6vlA92HF7lDzDIlqdLr_ALToT8rmT-3MgGzmMDRJp8a1r7WVoNwRNaeMnVmWc2_WkipwmZIvaVu-fPBec5S3M4-5YgkalKC9hZQyCNziuOX1MmkLkW8qHd5grk8sh1BYuHVxd0t8u3k1EYeSX9HCLMY3n957hBeG998d4kwSDI6h2g56yHMx527U_Sc7IVwUpkOVSEmM_kKbZo63F46G6blU1mPZOwzN66DTpc0WMWO-EwG-YpsYQlC2lxHOEpveXd2cyhp2MhtVO3BiosURaVDR3sZM7xudv72YNTNpc250onGCrAfMbENY6TczPd_C6gEwMJxbXt0Pq3zWUPglsq-kicMmIZDnS2vj1cNjuKmIlvCM2DyLT0kcqeNMu6QUr2AXm74JJb5hVySDe6-QKzsnd9a7m5EkXIibh4sSZ7nkpujARwrDM9XQDDtMOICDVLbJnDCUuygx_4A_QN_uyL_NOrZ_ofv3cvNWNrugM1FANTVEuTRwUTODLzota2iQ25k-qx_XdxdGgavcvgTaLdSna6T85rGqRd0crIpyZanK9d8uK8NuBwiD5kim-JI2GdrmZx0Ih8Uu_ZtcLTPIzFbhSW3zxN6tSDj7PMMeEVhpwuOXgIdje-xROy4iEIAI72ASG8XrMsyamAysvCt3DvAcWgp4eUaLpClpgQFOuHfPuRUtAhQu_P6owoPwWAWwLAjFUMvs8Rgr_umnjLkXqkkdUe2l7XuMazrMlX8Yc8UNjHMHftsv9L_SzT4rUwcFL49zD-rzCTMboGzXIOWcnSnbF-VDlUmDuQrFLGstVPmWCyUeKeFKpN_BX3n4C1DiI2lrY4upUudosp9WxohilyXHv6qddGHsM3vA_X4txJobPWaoNgsXoAHPQ2kuTGgu_ZO31NWHmrPHWtrGB8Kcf2hCZV36gIbEA3ewLGOx3HnKFhyk3uML_s5JvJCyqhsODAHRcLuUUkHGEg9MV2DiUdP91utmmKTvujNPOCxjQrog74b7ZbSq33IUlNsIns3QfUs3tBh7LENTxAZljGpRxzE7EFeMCFzmMZRxcTfou36rjdNPZyfe8x_w8Xn_Kl3LsAEVOSWrlEMkfaF-ZJUKYC4971F-bHaB3EnpVk_TsGmas8E79kjj_DbUkQOSFt7cfyfH57yH5FriWXF5SdN7MSmov6malDvzwSJKxTj9ImoLj40fRERnRBtOh5fhwohdTk7JSZR1VI5FAQ15_H1KoXyEb7fwbc3bUyItG39JiD0SwPw_-XXskCOjBD6hOySf0tylLzG5M0JixBU7yR3CdXvX_esgaM1-e3t0jT277osg4rjVngiQ0I2qPSrTnRZ54QsF1DEdy_DS-N1tOC985mktVY--8dMGmjLN10LvMjvXjLtzWjzbHA59BXsaHUAoUB6i-ISsT9-8UQIEIETva6zfKO8ccHu_hwLx6wppLX-iOApe_GPS9YT19keH5c9lqvtL7fJQ-mQSUYvahlDp5YNSmjZAj18U4oJ67CtwWlWzBlFsDc1vvxq9uxguZGYZQFvBMZBlnGLf-0IgTM6n3CPvMhjOILz1AUZJayyXUDQlnj-TRjPqbE0tzT8CYz9IOFsJXQFClvyoi7JAtwpdTVRrHxngtvJFnfnXPl-_LNxghGZCY-5OC2sDHBvco89S4WGDKTXxMuPULnx-480X1Yv8YjO7uJnvR5UupwSDoP6qEqoxh6R5voPRRwZrOaaY9QKv6xHMWHErH-Gy1lRJ3BZtNeNxUOYdI43hz6W7dyQ6HfT3ayzRR161CzWT4y_KvOu1SUuaNDEb9KLrUcCG8ACrOnnRnlA-4VDsK3DJsYSNUMOy42eWZFG8bt7rzOnZXYwiXCVMuAtTzvuAfr3Lky26yIwLsjpyqjuhf1kAaOvS8urcbUtAywBnPRICr0cBdXmNCVUKtmlvV9w3-mIwwZP6ntI6tBkssUkkhE2PEJg5XSyPz4cu5n58Wzwm059GFu3seP4h9LqQCxdpzK3G04Jil5jMhhhemUnp6rKReDY12rOaLnm4Cq_yAL_wY6I8luHXbKMzboB29JhVWUD2hHe_1YlPTVTgYZoKJGckxC6Fs2xkl9SHVLWXiFwtPPnATzotwDb_hQLc6GZQOkB3wyRjWr6aegggPeZo1fxrkZbfK6CNbdesfeDyOAoUiksNV6LGwN1QpcL0l0PQkH9AUzbN_vRy3XQCSFr5vQOdN2YOqXQCzSH8fIXQDswhZXBqpKfryDxtMXFNqwBqC7jyTYDoxUy0vknppkevfp4A5XQJ_QyK_Aj2Gzp1umFsGweQl1uo-T2nqdbFSoayfTFLT4Yb4hVJ0lu4rcSnmUtBhQda0rgvRfNqrHOHaR-pjZuy80W3noEqRy625PgpIKb6zydHryFksLvsju59FBq9AOSGIvc04d9ViTpfGlLd59cUapBlh6FNt7H5mBQoVMRF8QJEm3S5nLpy8sinMf05kY3f23T4R96mmN3XYBSUngu2UUxWOgtpLB5ZYwwf5N04sGbDv7fV2oDOsB9UUhSg6pMXf70E5WC1OI-iFGhZTARp8SL091QedN3t6frnw4YlDGTRX3-U0D1b4on-MkfoIp0FRNa30JGdmYmiw6LWgd_5OC4kX5U4qiqiY_7IEkJSmUUmlkUueSUDfJ1xDKeYicBs8F5aicXYroX_Pxqi2KyTSvZDFOx6fkZYF9NQo3XECXDJWiwMf6kKFA_9v-vLvWupeA8WDhLZgOpxwy5kXILtGReQhyUPh84mYRxq3QAx5y05shqrWb9MJWP-nDuSNWO7fisb5LaOhP1_N_dnaXGetfosAQC3bV-p_vwZSPKv59YocqDuVw1ZWqeyA2zFRHBn6E-ZFklKfkPo-aZkYxJLUUCgQCvog0fyqqjYzOdewPFVMiWrEZS7_zrfyk9Dhv1tOhQ1WiVUwin2FdFKDSRtXHnDsuX4Hljupp8CbhIzRX2EBghb3FaomnS_7HaSo5b-9Qdo01SN6BQUA_OZ80jRhLXg-7YrLJCPEfwtjH7AJe26Rab-Ns3ZKOSIBlE6hlvj7CUP9PHg01Pqls9YqOqccvlo0BfUsiNbaOuTZmg0LiRE_LU8cgZg0IQC_rz-R-Y4PPIo7GvD9gv7QUYMPr0FtIardDSg6F6CiivxnZxxR1cfidYIl2KFqyFjtCrRNds_dW38g4YbSAHuRzVfG9NXfgmZIfoZ5v8z7uvmy4BaL4ridKFA0uKK_x3eC08EjYnL4N2oLdTaUjoswdNTjK6vdgZvsdxhNgv5SzeLYOKmcnuLyRCdaN6SFrlCrGHKd6L2Kp6uYYUXpxrw919t3G-rsRf5HiKQ2eY3RLqI_CNj_-qtWU5LqDlY11LaSeqdDq78n0YORZvbzCkDDy_qYivlDwLWHk8YrxhDmj-KY0nqaDY3aLJBvM0XdU0vfQfAd-PYGp0l0doKtVuGzF5BzvLi1pF49yea-vNUGSvZXr2luu6LaLTOCOTM5yeOJJ58NFbQc5aa4C3pUnEftZ1vKelB5_vLHgvLPxGP-XCkHdrup-WKkN9MP4ANlMXdp2SOQuTiMGJku6AmNkwKqCjHNUGkUR9NGp74EzsfQNbwXCwQmKqsPREh_WdbDB1Ovq63zCUPo7DWESKN0PP3-QTjvReFGAzTfH7UWESRWBeC9r8f4mpB9tf10ueqF2kOLuTTo__JUj40uGg9ZbUm0U21ozltNnjUHEPRD1-ZG95MUsAexsogoB4v-YcZSLZVFPDE-3FjOzog1_6Ti4yKhLz4P1qxAtfyrURVWV42AP72V4VQrkTd17xa0a2CrXu-ORydLIQ-OC9Y6KYSsxOdn0Xp2s3pGN-atDEydhyUukC689XXisOstkPqnwQayJn3Cj20d-r4hiZowtuVdu0j55zVg4nbaQxFKtpTgEFJigBeO47eHKLcTUz58_PWAm3o8eeZUsVAk9OcyUuPQGiNs2MKCPEA70tpkpsnSvuAHZyCxpL8sTfbkdOPhcb32mZRZqSRzX-0ssomPI4jkzqX7rTj9Z2aIvB9oQIrcuxLySbtDh5jXneLkNdzDSWHy5JhUpiNeiPoAEd66J287Wna4VwMzVVFKSkMy0ocldiQaJfqanf82Wj326TidYoX_Oigka613Dwmt1zGcZsvp09PzBS2xBSLeercyOV4Hj_sCEWrsL7W-gn576jRYsK_5QH1ycm7XgfbaPdSZNh6Q5EthuLkT15x0Uqdl55-j0NcA014CQ_s-uu_qxGYMRYNilw1wL_z28pNLY9dtBg6NV8r62DQYPj3LlsBqcqwi_M6yd90QPeZppDJt6sBdwWEEY8uYpT5uc8ovZbtly6nhuhmYoBmxJ4mozMhAKTIkdTuEgwGipmZZ1OdMTb9wzOD2nF6ZGFeSg8GaZECmmXisVRsvW68Th2jwCwBKC7noLByEaGPZF6LSCYIOQ_GMWoaqMOXKDHQzz932BvPUxyZ2ttv2Eywo_FQkN5OYQ7dkLI97sqkWDR2qsZJu74r3Zi17Q3cvxola1EQZuLIzItgd74V7ZSkbirtyCpo9ztZKHbEuTtK2l38rRtZYVxZn2RsFMxpM3zrlqdu2sBZWs-9D_IMJ7w6Bf-qL6uJ148LH5gSs3cFUmr3LJb7QwQOUSlVW197mELvknRaI8n0cJi8VbnXtXBCTFBE9z9HLCWpDhADiliL4qulk97jCgnxOMwc39RjipQ9itknawllQdRpizMNKNvil_SgD7qBrVuuhl9IK_BnIQzF-CwJAoRfxWO07_MMuldrxEul-IYjCI_VMmoC_LVaYf8m0peV1UktuM8M4eDvNgeJRNi_6bQUx3lD-9evOyn0LcqrCgR8qR7o8y1JXBl1gv8co08h1fqLFrCtSfXb48gr3HeY8eszt4fZirG1nWSoX5PCdcGZDuZG7D1w2RVhOEMp-yFMXrh6nMilTO9IQ2Lg06Vik1Iw-TSTYxHhkcA4jKApe2J9c-JT7l0yJcCGCXUnmkwklGDfrkIX0KbRSGv4WnSDnbHHaMzO0bMd87kYn6kMP-4uAWyNMVYxouU5_wMKB1yYsSlxH3xQk8nLii4lqlEulXe7BD1qx-z57fhIvUUgkNrlPlm47XwmWx9Q0FVhph54tvmREHsdcd_0gRC0DpO2eCkGGu5WOa8SLfyaeHZndPX3HQdWEWoqvNC7eastVNqW2SvUuMf4rQdcm8n9AdWD40_i_mfuODgUvk_qv3xKVQMqtePDLn3oDwAjGbctfjSVUeT1v-3HyiWtQlcXRBDt3XdXHa_RgEwPuIhkxdOl68dxnEC73a_0IxGZ4gAbNhkyOCP4N4knVOPuyxR7tzpQq6LuWpA9lKYX9i8eoMzTRMlKir9gwRJwxVEg0resliv6L1e7sIeDkXQ794Aiuz6qCpn_fhbudO9gSd7hPXCW7_SLHB7jfVLOgqMbOeNLcmsC3igJGmmogsIxT-FLxvqBXsQTD2mbpv5TVPesi77ITc1scVr7SrgPS1l6Ryw8evDuaEUKrurTwDH-KZOAyqrdCDfW2GSPNGXTNHe2XIAaUpTY3yj7oQCLygUIyKd0tRyEowphyCMxKZrdMETd__zAYIWWAQ03L4SIcaHJGx8qePQyNjKMJ3r75sV4MdfddnJroSk4h0PLWHLv4PcHGqvNljh9yUPDH5Wnh8vqEq4rDOd_NRymxpfQq4wrPCY9ro7mBdjfvmp4zVNYHOCDwrO5kJf4z6guFLBaR4KrbZJqjzEF0IJcHWpEO3G_cPGjFn-5bzbzjdt8P1UbkLIDFSMQ3-QXvVuT8ArpKTYsDk5zn1qyvdk5ATQTMW9ncxVZH2ZwYQKS-M-P1NNZAPfHW7mHjijtEMJFg_m2G1ef8C4WvTjHlwCHmJ0rOvb9JK4ot44D_PB6KVeqqj-dJpVQUwov-A94EldO3UQ2XYYatTDbF_F5nH3FJ3GEGP0NhE6rs0uS2FV0uiunucvTEG-QfwLYxNgdBZXgoHrOStKANX6PhIfMz9_HGVeieua5dk_S3gLE8VF4IAcfsUQFFWM4J0LtlDRmvvPJ0x1liVJvAes3iXKcTgVESM4x2o76iblhOxYPoAeNyFmEtpGpzjHazjW6ekzOT1rGvkBoXsOif3FtkVnWADJyheOOiAUFggt93pV83WrEnijiaPt2sUeVDAZahFp84VKGmSiAiu0FGgNTtHdLNYPxJwYgfLjCDwY87joDqf5xoPFHCXIcQp9__xGQIv55wVBsan2BtUOq2MXrvSbDooUqnAhU0F-93gE9UxT75Vi9l6BXIYXr7vHFnwQILHVnQwPcf-cYciR_xlRdYqdsI_E6nAs7IydOcn9nVxTCAc32jFhcUtIo1a4RftrXoPoYOIMxpX9-XyqHrH_VrChjvGEmfuN7hdqSuNiGNEU_tLwA9OhSqi61L5eg3qMhkBLZOOuBYij-dTw0VvrjZZrIaFfROZtUNFn60edd_vwGjwuali8keK_b4BjPMqXNeUxKd3TdH1I8uuDBoeJsFhTOqbrQG4MW4b4hKKn99TajY-RfOrX4qDLt0ahVf2bjO057e06R4dwkNtYd5fJhNhjARmUIaAU7__uKbXHDAXRgQr2KOzOWqD66lI_VheBOt0_OGSFwL1mmbC8fPMhTZdOb9I69Ho7m3D5f9ZQyy-rr0RH1fS3AymDvy23OPFx2blw1LZDD6iHLZ0eOSYmqWBjt7S76h-W5MMPZ23e2kIrZPaHPJlcGKCwaz-jhjg5Yz0y1qz3zKPVpzxllH3i2ZBxKjxLEa9Dc8_iUO9auj0Sm0z-qvBP8HDm6xnVpigGsNYAtvz4QpMlOSHv3BL89OQkhb1EwDtCoc4j4DdtmB5rSY_z90333W9haVjOgJ5ENCGdjOKsxkk2zc2foOOGlDqlFyyaLZRFW4BE_PUFmVzrsIZwUdHuPtAzWVZJFAZJ8daTxu8FO_KIFc_hvkA9XtXHb8iZ8fKSG-hVgvM0jdTQd31MDpJiOniRRPy9KQ3kUtCH26hYpdcn1L5XTxA-cJZduxTyU2xL3IhLvCsgz7jx-AG_htYjeFY869g-qULqrfUnsXL9Pr8DY_2tet5Uk98b-QT7Hc7DH6esZi-zAZSsxOlpFv0gG-LrOBa_E6eZs6q6gcnksfz-EAOozxlNtjfUgRgAHVgNHOs1GALD-LBgguKrqwTcuWkVW-U6lGV1oP9CnS-X7UMl565y6LbunViSaXPbkwekk4KWw8yzOnkeL8ZAz490-llkYmHVA2XMPzjduGSXrr6ETAZMd1aNzPWnxvgfBA7VR7rLVqZwUYuntfsGiUAFEZkSLvS06SvbuxhrFST7WqOgPbQKlaOqMlScIySj2ymjoICC-DWg2Lkl7Rlv3XrBSJjSbfxQFQry_G_ThZCyLtmoT7Ci1prrdEl7gYIWtVYk2p4q9_E55XKUBJLVCvIALKYLPg4_kRxCVDrJlXWLUVN34Wfk-gibP1nLDVMA_upiuYqe_w7QaPEx88GaNQ5ED6RT4B__Exq-4ht0oxnVZt61OzGbMMaxa6OYG9VyhQ_xYY7ECGYWgqs3k2d93_RKik8aZtZ6XUij87rw1Gyfp2VygXgPoMHkSXjOlnRrhoqhvLicGxOO9S7p1iVwEDLqDAzpFlPA7qM8Vy5-7mXhr7qgDSMoEs9LhvLGHxKfWDBRpvh-ScRNI-uAs7VzLGHdwmcPhgeu_aDBHBxZGU2B9vK2yvakpLG8864I91sWDx_K3hfeHJYj-ZISqRLT1snS4mksBJkwjoL2hphrkc3OMUNll21somH0c8EGC91eUq4mj-LQEtiwqnQ2LOK3UO-Bz5KCG3-zSFfic0it7-IqrsL8GzHG6djUwGvY1MSz4RPFLrG2VqjPV8mXXJUXQqx5p5df4MZiLPdJJMVpyqgAby_RU3pXbIfbLq9a4tb6l9xODKZcw2TJfhDlHFdi98k_IUUSqRB5ne15Sbvw-u2uP5rwAKqGJEcIVHQaPc72a6dRhpc1bfjLwLxYkRzhSMl7OIPKGjEJK-CvuwcojIDP9H9gz9rQpYy7lA00UNCQTwPk5as_dADkFDVEOJgfoBg79jJLhiBA-c4LRvRfqfZk243zhVPOEZNa-jsS6OrFnv9kO7Txr4Wo9ojGeGkyNx1BwlBeAYLnCqOWdLO2RimOFIy731_4eK4kreK9DCfhMkwKPYOvTNYuKq1i2lVlFDrFt_JkOedso-SYP2ofwc5KLpN7TA2JhReVMx_ul9dtUc2wvnGl07AxCTAAxtfPISxT1ejzeAYzM-Gav0H9O5680QaB2DEeC1U2lFbY3rL43b-9mnEUXZfliKxCh0l35FPA7SmXmxs-915m6tIKVaom54fq3Sngv6ZsZ2lQWyrJFtE5y4-75H6IM6UG2aj8kuerMXtAk1NDnlviwvWEiS7rDGvOkjJG3e9lMTN7hvMFMD4Iku3964rH3ZpG2pf--mRP1uabFkFzZx-2vsLd4CUuBsAY0pGIh3fTYjTGWQ8FgvKFDCjx75pNRfOF6Jv24QRGBqU2Lav-saLGfL1SME7hnP4YuywGF8ZpGh_TswX0Kt1efJ1l2iAxWadQtbMCzYv-r8udrdAaOtKLkr4NERfkRTbeDW2kzZNU1AF5Vn1I_FtFGs2NZy5vo4CFc0IpJWjOq1lddGgxj8cTX2B9hucrfY3nMgWMiwEubr-Ys3x2ibVUMW3TAt8AqKU7hz-jU2NYWaBNWnicF1IvDpltFreAG-jjcz41HufD-eRI_Lqk8Smuoen5oOXKx8s6K-Zh8ZBI5bXZ-l6OuDmF_1ixpb-cKV1Dsv7iDLKbxvZ_MnFRVcZUUAieNXYEyqvJniN55-zIh7D1c1m9nZbIsRTzM7e0PCHqqadnx8UMXaNvmxqVR-hoSlEcCUJzE-Ytd-jVeoJoPVvcY4w7e8Q3kHaH48c9-r8FBDn9bD1BhUP8CCro3c4Kpr8_ynoK1a1wyzb-nqnMI-4RF0D2z3nS2Tn9Lo_o0BiPBkRF3R0vOSjbyFnLFlZZUV5MdVnb2lkzAvvR3EU-kd7k9I9zsyI35kRCtR2MS6HTRjPIiGxW6Cs8Glxzy7V-FREoL53JLbuM5pYevr1_UEN7UUP-leTBUqPQ4THT98C7SuoAdENdgKO0_p9UCLIdFUkEBjMXIl6n7GGvRsNC1_n5Jgmk9cpww3rk3EVpS8wLjg2RgFVouCIDfYpxTzPNMpWKuzmLnSThSOLTYf8sq2wO4n3vIuCNIyAP5S8ZJEozz-VeEfg6cn7SotYnjKyl8vSK4Sz8YYaHPjTV6OhzFAgSNSIDHIX4hI3M1lJzS9lqW1UmwIw2asdhLvEJzgMFeaKvWUrmv_fuVrOhVUlNGm79SNpUM5gjvd_a9Vw3EuXsGcQOF6gExQbIlARfKQWd84p9VHH1zwtof29ja6vBri5I2TaCQOdiMHi9PHgDkuiI0DnEzJ6zIZfJNCWOeSXPgUOevRh572-HBvZoFf_zADGwZ0XX3CNsWxWXikde_adcOoEBF5emY0_VyopAULOD0SwLhEtJ4fgovPg-Iq57EiT9V4JEn9G_yK9Qp-WVu6BS85SOPXEeKpbLRSDWzdg0ScFyepS-QRTg1jgt0zbiIrx21kJrh9cggDKLfNI8xxUsIw0j1tS6QbYq0yCqIVlBjRgVfNjc_k6vBFb7HupIHzOY92g_9-3768F36luGmNRfRckQhr9yI1fmpS7rmqLZyc8xS-m5_bscLNXuqw_G9n-L-UE5A51NczjOJ-Vgk8PkzRLCpPhgCdZEDV67N8ih_f5yxcQAc_GJ29vTch-cYywj20ozM6fO0qQeZ_in9IH5wWN1irv414G__wyd_HDaWRAfZBfKBA3kgxY-s8Vv-WZk6GQnCTYlvq6y9jXx0_faQLwtZSkNRO6ylgi3yRKSFZue2CiwYqQLByiTuDs4AFHdMcH4Jk38d67TZAGNP79Nc4_ahCggFiXsXucO92ScvvqkaaFmZRT5nk2Ntb6alOttEKVslBS_xPKq71H38eE6_uXjPqob5MdDE2Ae0TiZcWTZiLH0HuddA_eX0xRgwRIPLyW8O5xVw61p97WFsPsQRZji34Qw_HpAapLOdCn77rOr1_ooubg7WmvT_Gob0fgsWxT-NSlSiQ5XEkWBodT2fppZtDoo8cyJpJNc3EE_0gdPHEAiHFO-XKSsOLccq93I7e3baNfTKDGQT1oXNBe57XlqcmpGLS0N5ZDq4F4iowEeRm0KvxkuX2VsB1LJcPFy_-BEWRc7FqhWu7O7WACELrehXx5fVJsxDPPGHCU4iXR2WDqI0jSqR3bqH0jYA-EP0lOakNvna5sRwYlLtsqZGoVL1CgWzr8c7btZR6bBIF6jgIPMOuIBkXZZ_0uL59vXEFck4JBFhHyI2kmZOwx5uRxGm2mKVd6Wf2ZKIvA6UrKuDbrnj13yNCZJqG-4NosqDYl_nJNrymKEBJo38bgyGkh1OE4XNQN4q8BJZUBZFxzh9Xp5GAAvAvkZw-835aewYdzWgO1Voj9X2hEp62LVlVzOAxBsXiTlOkkJ0tmFnNIP0IH0cme_lq8XwZn3c7V3pYlWo8iEhEYAm3eqeVp94yaIB0ngb0r-bwns98tOeWwjYw_8_veqK8hjNifhacxXu0Cxb70xUNtNCAPLNT5z5JfJCR848pL8JCRPcMq0HHxUl-nDGFPjM6hiRfz6t66FGD5y4aARFQoyF1xpRSTcuxhI7EDZ15FhHvnPnvaoIBLTOHC1xvl9Y_We973D4LnKvqWc-bdw_88hGAd3h1KaXe81VVLNwJJVp-szDvmzgS6YmQC9VoVXNeK--35SsSqffb5ibb8L8ci9A8HVIPIcdnv4_KqsfLYqhBrdi6JaQH0DLqtAV5WVD8yNH6iiSAMDWDezalYh5UrPtfXjG5MVppcYcA6kGwjDVRUfaJV3R65StKAu_0ol4zDa5y0bDCFUfNohuAsdIGnkyR3fOfSnjCVxOsk1TCjltOhUV2il_VvP0fP5DTGthenvf_Lhbx97VuuvYZR1cQlIYTwxFiOYaGjI7yhbW8ysaY77VHBqjVfeHoPYQZjEixXXL007bq_yAYE0zsOcp01pgdUz4eavlMvRmGqoRiwX0CV6ifCcQL8C1mlOfWVhYR18m4jUbQ_GWq3ZkDPCz8BPtOw5cJ1Hze983v9LRqwPf7ZzKix4n9wRNaf2ZPgFFJNKHc-RcL2EuE8NKF0UWqmkrMrpGqeQDozZVDz7q9z5991efe1C-HWLdtM0WNNM35-jNs3IJx2wcei6zPblc9GQDqktoiRh4_ej9_1s2nKtm6z2_vooTq1yX7ShnxL0muKZwehVMoVKI5TVyo7zlZ-jlfPelfkRckr2LGngp8uyXriMymZEKLTrAfs-NHgqRure6j5cy56jIA36GP9QBno2g0yWihYp6Kl3GdBPWJ9oEtQSCa2VWcYZ_LvImJe80Ev-XQJeJmQe8CHsEFl-Xwpp1rrSHyLGvJsTgrMGd_E4SQyKVwJq9ArC6FCDo8Ng0Lj2L1ghu0-VafvTSqflFT6mHjq0UdBEcZo3LYSgCAofU6td5IzNeVD3eumgxpqQ0otjidlfU2x53gK92Vq4Xj8P7khQEVp5n8QbCm7JM-VBBUqkwmMV6mLvQRd_WuStDpkXsd_jnyn1th28Fg0dyAmujfIe2V0E7pl9U1F_6kvYTQ00yKeWsyIBvzpvCbXaLt1ch8V8mh7EzrZ8dp_zdqTZ7aI8EtuhK_7Hu3-v4aftyksHFa8BCPbRTC6H9TApgLcojn82SaUohtQvHMWOXp-icw6S5Y64E0T7fvimQ8pBN4PnuOGYmn3h7p-Jr3tAPWBkaVW3LhxNSeRj1ys_SOr1ciBFa7zTWry9N0HQsdxwB7eQkR7tHycoWPBWqK3Pyn0cLcQZfvrskdSzdNRN4DE8JzVxiEffPhYuhLgbygygYFmBZY17BeM9fYYvka0CID0vP_N16cK4O75muXG-yk4yzHv2hIiVaFhj4GHs6rGRjO-Sy6oOzMkukG8oT98QrhOaEBWkkH2mRDlbVp76b7o-Cder9tk6L5QTXW4hqpfcRjlTh7Y-wKqki_OfUnBVWsJivQ6jgeTbSjSjikinYeIJpxnhcBOPTa7MZfPQFOAoH5yBQXYUOuhxo5cInc2YQTyMG8FMWS-OBdDXb2dSue3fhIWCfifoKLdRgBA6Oozmnq2IQp8dsJepeyAyS9VBXy-iugghq4I86RheSz_GcVBX5ZVgd285OW4KSrbhA0RgtpADvuVNLitsBl2G396UGMTzHRur-pNDRxvykajUJE-E5Rh4TB_dsipBYvPApyPqGy-Cx0w0r0pjQ1zI7CdoSl2qwVw8RSOX89qu2_xCubgVRWonYWBtR6xMyzFEvCSW1Psn4OVSHC7WsAzedWipjUligqoFuIiObRjvnFK5wtKgnV1cOp8_RFUwbTKECBTBjfztYhwgEjYRMXBUYdR5Zm1QsstLkViVH267tnW8AJUVBUHDy3dzkxtSQtU8wwnqWjGdH4aTPq_WXmU_iPVzCPSiBsAb2cUKeTFyOFu9laTEx1NHaKXEKMuTACQnNLzoW3b7AjeJY3iApm2C1mMgEA9glAdN1EzPgH8El_8_u0TQ9dUFeBVcoWz6CNc8WzzDxyN0VuJQnxra3V7xi1m8UR3-BEe6bk_GpBVEOw6M6qMdC6sZLlvr9PVMHDmGY-BLndHXTECZrRFJlyECHB7eY6yJgmd09yOIvBa8zNSCmX1dK2JRbQycpt_OGQwGYkLjJJSUwMs6CHhfLnl17knm98YsSQCYcCwnJBMAJZk3sTeO6DFHTZmaC1LkcT0QoZkYuzJg8DCRLteYwxYeP-opxC5D74oqY2A2ZPMN1SYcFyuadQW7dbi_KU2vZR-fVL2lvvXJp1AXxtMI0ZYtDbFbaO6SkKBmuu6w8XOMLjw_NQVlkwqDa96Gn7LsjfRlSpiBkxeaKzPTRmS28oCtKcNVhufy2Ia6axli-ifRxGCYWJYXMFp_Wm94liqKp6scZ1F6peX1740S9_3IEMrGefmFHMlT_nyhrSa3OX4FjrR_dgNjI596g9zhuVSbvgAAw_BDiWHOdxvU_WRf8cdFsS6ZIWBiHzzm-cwws-uFgbAo8La6OYyY-iw9CTaGY6Bot8ud79L7kZC1cCUJt2OgcgiXjdsClOJ9pNX5-gYlMwXkMtTDyF6PxBXTvZy6-loZnprfXFKY2osWXdOKQJUr-vph8T7Kbtc1J19yiqaF449BEIn60VqPOziA6U6RgPxt1jqkjlK-VVQlh5etBj4-gBadxnTsYVl5-jmN03DU6pG9FVi9oxSlP2BOis78wys-8BlfYYyKdNH0dGAFyCaEhfwjxkQyDXbgWKJjhLa9iXt7zwQ90ZtVKm-xI2nEQOHi8lOO0CzsiEAUnt0dK5zhBz6Mm-7k7GtRprJErhSPOg2pmY7HiUDOfH1u6CZALcq8x8yJAI1IMMTwE4UA7hmBvPIRp99gWazgBLFNjfKkyIKmwXgsSVIa7XhQQj-cI84TfK8iTYCGANnmwzdU31N9wyR3UdFbHKfJR7MbC2gO1xOuFB0bUVIOSzV95KfnVsvlxz40N7TAvbHWpQHEa-Ul3MDtj5cosP7uNb_WIdqfe319JHxCB-G9nESPON1xGwyRAGxoRjze_YQOeH7t4P8ohx9m4M4zBciKiUXN_RZ6Qz67mcwhsy7gxjtF-UrlGrPdbvA8EhvxXntvJqhGYJUFvrENB6GAHLe_cImESbhJr4RGll4Vyt25cojb-wsMSYYMekyQrTHGTIpxCDyrDVNxldTrWcHbO7j9TQVVdTS49RdsnCiGAmt361qr_5Xog0gsaWiuj625RctoGV-WLgEz8Pg-i6C-umhKKPg7bGVz_XTmqhAVibR4vT1QGAanfNFA4hyCwi-FECAl582XNzNMBCMRYTbJsQQwo-4yNMAgFRhRxJGYEa0-g38hxVti2NAPNb7onIZdP4Zu2qWIwkISv-Dh8V_veAt2CkiPfIbGI6_UT6wTC3nFbVqi_YlHUEdWraAqbc3tTQhePBKtONv-lmL-TBLhLu0TYmYGJra5gZXskbD4x0NkYKEwrhLb-98kyi1inOBlWgySfxYlB_B-NSUrVdDnEuNmQJ6OwdALab3Zboodc9NHvlYR-f39W_K5xusSO8Efp9B5mlu5p-JE27h3Dqu4EP7yDndJrZZJRuDVqOTPyjgpZrGtVbeYiLDpkFRecr--SiBrPcrqrGmi2gvQFfz1xZEmHSMEeePPzKCVCrllc7-64luO-cT9T_Ud7-nWv13vk0HYjzTnJ4n6cfNcJFZGT8BXSDW_s7P-NBRJiOrAYuo5mSxwgi9L4PEO0UFe2vFTWU3maFgv84idTAXdB33vWqixd3PknYUwXhicGOhL2DNInbUmz181qrgyeyYjBCJGJvZnvPplbvWCP8tOayDSC2B_g7kAm-JnxmDGs0QIG_Sav19JHKKYu2q2ebKAh432Ey54s_t8tTTDDI9OFz7qhVX6Zw0DydpAoHjkeBz-c-kPBK18-CLlUu_fvjzn9eIeKEOMHqwOYn_7cFdprL9Z_Pn7eT6QtoVuMo1v9OdEhZUFaPLJzquEQqgiR3XxmaSQppG478oEK1kuXOiOVUDOYD5s8k2IAsqmE_p639nNWE1gjaQ1BaTthXEEHZHp7rUjoYwwgoaBlCnbh6Ws8u2ox718yP26PuatSHj0yvGYRH9gcducmAWoLwzmyTvrMfDcvwzpD2-CJeMpA3s5rKX0G-D4z60-w9DlqmK-JmZGTKkpoHuigOPr95T0K8pY444awC6bbW86fAVFwHwBRvhWC-xMoZ8qOIHbymZJe_rHLkGS_jinJHdzdyHpqpW94Xxgq18DMwY2fdKZn3e-zwId_lH0paB2h-yepHehp21dULdlCK5YJ-JthFfzqEba-bxxEidetHH8RfBR9-odfJjjk0U1iRRWHSNunIb4GLP_3-c6o8t8GDj2XVMqAgNtCZwX-Z6sG5WOp6gwXuc41sP15IACNIZcnj_3z0VrJcYr-ryrJVoOUazW8e_TVOe6WrVg4aIx6eu1MjbxtFYKpPCXOrNlvXgQHUwTdcp-j6Zlu2uaA3vXi9O1n_nw39SQ2pOk8CevedUN_ZFmVDgeIEEZ0KO8kgb_Ep-wXwXbBBlMpWDSuUybfsNK-EuU-z0VpDqqMlNYK2IR1qTWBUnFbwTduioUbmxFA80zELdOspasxUgb-atHY9tSvpSMxVIgnSxeP_d2WwQ3e_QD-0LiJ5BOJUymH62jt9AGvQYfuZxlxH5TuerV860s2lUrz_8mcTUIAWIkZgAV2q_2r7xuhPFz0zjK7umi9UJpWQVjukwJJoZht7Se_nUI1FwMtZZYSh75bxfu0eLVj9NbWmNTQlpH9czWg8tZYAVrVKvNtb40gDYHGGrO2YVN9UBfr-jnFQypL_FmCxMBvFG4u-8GtaoqM_kAFqz0Yp2Qp4UkBQ6pCE3tdS9RvDJG4ZVlkG0K252MnUbrbbg2i87w3tWyhWOsidaQWAdKGkyCX8J6f2nFkl2xoXu8NJYzCry1dSCwWWx_rJyA-LhBCZ6JZY5Qei5cSYHmf1BIXuZxYg7SQVucV8jTm61UytA6vQT6XU7LWLHfy8jtpXDgGYFD03-4Zhh7o6bbswWEZI_xCo7cr5fQ0bedK9RFPhSo1ng60-hIZKoGZf0X6Ux-K9sCaNex-c7IiiX2GoyYLXlJTNA2mDwHd_vUei6g_c7683U30njbFdcc-2ak18aHCvmcrs_vxWlvPe95dqo47xkTZo4ihsj2HF-MiJxwo1hbiXkSCgpTDwn_Z0-mge3f596P9Zsqf-5No846qDlhtdQhAImS5qEyDSds2SNW66YBI4d53tE44HCQgZMagvrFSpNkzp7WOBJ7a0u9wy2tLFsHSx55RRB35qqA07Fp9Cioe1EeUiiHA934LJjPGIfPJuTm6h6flFWtYMz33OYSYzba6b1d5e3zwposJ3hlcM-OIVuJl1HVyfnhWAGuyyNbEUsHnOWftWtCCwTTYpxZQp5MTo2bNfwKU5XZObiEIw6wiohRGFpybqJmqHgWkuSl7vZbqdsUrIx_b1pfaqIA5dAIMzLJq09DPv_8gCU267p5katZYiRPNqWVY0wmdc90TU0K5CKLvClrWVZm8rNTbVsEXLru4c9vXu8ngScbTmot_BTbYfTyzY-hZClUHNv-3SLYMuqz6q39_OJBoAFzKwTOQzmZQlAANINZZ2VQvWryWbw2pVxvnQoto8h_P6Wsup9bqydaYwSfVAeNpjz3M_iAl7jTxaCa_X2svzbRCDPZ6GSafSWg5b8E9NwQQis7ZZ2EqinFBvjGEo-bQIBWXsL8jdCkRtAMzDnY10B2mxZXVVIysCL1L2nmiR9Y30DmvdU0l-yjF3mSjtGp0SlV2o4k28IRUhF9Rx20HrHEhHUC8gNfonplAbxwmYRCvM7UdL50G86NFkdD2CnCiT51dss3p7oxpDUHSt9GGZqCW1AQJmjpoTRI90NLcmecORI8dHhijhd9I_F_jyvv8kypLnY3hWdwiz8tOOtqUA8eluYdYuKBLVoJZ0OUoOZQ5rbHXDJgNKmOCUG215RSCi4JsBHgpryL6ubEZsciW5c92TAIgpTLueqiolKViRUHAZ-4fwKgLmSMduTOjdEiWNB2Qrnd04tkNKdDpeVTnx8IfZS_Gc7OVptVzd2NjLEGiLUYDZRRjqelrOxlGRiOsr4h0MdIfeehjXkxJygoUABAlhZgu9P-O3cJ1cBuC1t6sP3Z-3ZHVIO0081EL3kD-nBgWeYuDUNHuHD1rzqkKScM6b3QCw_RpABw7NqECUwb9I73K3icMTdETuOXkPChipK4vK8YLRptYBNCawAEmW_LsFlCbUx6TjevbjoGqIzoXoCdUvnI-5IgnyG06SCndblANfWrWnrom1PHT7F2aWAi20dA2Q-9V292C0zhC7qZwKvlInsdDPOGRaE5fBygs8c3Dwf6RTobgT1yI2d5zBjZFaTpYjyVyD9vcJ9yaA_dNHe4q2WKqFicUCOpzGmD8bulVramTSKXEDpdcR6KyflpFyDoeeCr5WEJYEw8_BfERdPc-X2a_VYtZO2pHWzFVAi8aohxyTEIFCtmz_sfoJqSGLtnLPqCxH98UbPUpHYrWixMZHODpqnkRFP49NIuXPmuegiF6VMVBahuG0Hl9brS5evwfyTuXLM4oveo5RIp7jV7nSG53XxDDefEAmCTqPaWygv9QN1K0cx5MbM0DIb96D0Ol1jzf6duRPP23goJy8c4BO0Bw33uMc1znYwI7C7v12hs91v8oKx72s2X0BwyMAXY-nlkHFCLvgj8fUasnWCUWdFwpqD0EOkZQnGe0ytOjz3bAL-zp0ObDb4sVp7cJjIh-fn4MUMpnpy_MhAF5a2FKsWeVOoHs2EDPGnniuKh7h9zmm2RWJMNatbTSH4rc52S4Ode3D4pHqKOiNcNuQgJAGuTIYTKaZ4qCOgc39BIXt7TdTDSz4hsQb92ybKWN08BC9e1LjwQMY9iHwtFP4dmrcsU4iSSmZInYztS02xMz2g9-dcM9hM2ffzIHYVOHqs_bAzSLnbdG3v5mU4oN94Buoqwbr0bS2NZKW0O9dUnV7ZujUeHh0qQ7NbqVod5XnVgJQhSeYnuM6uLrnl25QRzNButTFzNG3W8mK2tAH-LSFFwkXfy2PKaHTellr7IwwAY_RQZopNcAv9kJO7vZcfOafkqGIneEF6FnzmjVcyW_L_dc_q0CbHg7vtPirdL9NzMVZRfi7JPhNBnu57qKTs9HmV-T0mo71ELU-Vq8Un2axBqYRvNilMs2aQ7Frot9gCKDCby0a2491dXxLhxZuyj1hnJ5C3ZQV8VKu8OIMWla85hRsXOCeorTwnxKoS05rueJvifIbLBtEr-W3gBzcc66nexRtFXvidkSEcXZvfAT1AaMb58LE6HkT4wKONNYZda1Z8UEJSdfej2VFSzpR3z0LFgr_rWJo-rTG7pJ7XXhWv6LEYedixo7b-Cu7vhUHzobMmHm0Y0PRITr0lTBGIGBEaWe8IQ2PYsC8pV0q3MTZfepKxjxlwTd_3aZJzqcpG4nqXjgxwLRBh8bQOhVfzfnSuVqvqnVpq-WdPw8MDtHa_vplm11njdt6KFqJ8sBau9xdoucNJp_rUfCb8m-q0AXqEwaPd15y7n5ScPoetshqum7uv9blX9pbVhYHGLd27y4N-RUWteCbCIiCQ32P6IG95W1w1GNqCXucho6vGLt7NsNMznhUnWS7k7T3e5VZqtLD_NJq9zD_ijTMWTwQPAshk0waitNsJKiUollck_KonKlzsXeCKUC_Jc5KuUtEFhmpKS0EiVOdvmGrBt8b4E7Ral-BX-JcSTBDaQ_WKZS7VqXm1c50Q61rf2c2RPQVU7vFLkqIQGALY-J8E2vpo17IR7sPZ4oZgxzIbX0d1aZ5RKqqU8VBQTwcLBZN5PZx93ufGVSWn9mC1iXvr4WOPq2LYF2OPsK5_JJjGEk3OYOHXUPZGu-abhcaSzqbedPPFRbR0UvMCWKMVLWsQTSs89UfJY06k5wZPcys5vXgsbdzNO6GjJp2ihj8LFA-3uTqxsbrKnKXQ0V3w2CJ0l0I-ZxMlQdMJ0kDAGCMD61XLjXjM3r-CwzkECs8bkmsBM4wJFgmCEVyzKzZzuvnm8aAP36d248tjN2ew2aaLzSGFeIsJcg5hyDIhUBBBkx1QMXIqlzFG5zgeSR38cbDDM8BpeYX0C8U4hYGiCCBIyhl05BLTpSfxiMKD_0-2cwokPXhtg5W8GTdVs9XEjz2VPuR13xZRhjryBuLPNGAbAaOSZfsFXzFTkLiiZ9iohjHiIeCYFyV_fPLBtfeC0gH8RcU8te6HSOZSG74uvpRLLXQosSbI9Yta8et09lTyROF3ovz4X7YFaT-T8Yll9-yv79HAubKoTD9DI15LKApaPvqCOMPih1QpDb3Q3K5Hgvg-4smOpmAy0RC20ybVeJVBgcCZr1OEfTgTrWHEGI4SQ2-L7nt-86hppqr6LPrabqDKkQom0mmZa8OatRulZvK4NfXL8UWT8r7ZfNM7c_XQyoSbsgmCGH8uQ9u5HYDsH6Eg2Z2ba8v8J4sGZOj-42BZHsgp73ui8FGtgESIs_a-k3OTSz8BqBOKBwv3157XFXlpixtmdQKFmLxCLhDt3Oydjwr9PiW8mZzS4HO7P3AmU1CSguhI7SUKmUQyyeVARuIpv-X5I_5tz2E1LkMpKYLFYVZQGtXMOiQg6InWhmJs5WjpYR4L41-VHRlKd_xRPd2bXeW61_KorrC_1bI_bnrYPDm-KDVkcYl6hAnzqCOweoi9OzuJf2tzDMXsVrGNNgkLEBXfNbczFG3tbohIVbA0oi-hWgptJtXtwY1NLcarZnRuPAYL4HtSgQj1mBVG0ZRgArnSD4nXRGxTVvFZO38f05PAhvXF3xRFhLM9nrw-MREobUEgIIsZ0DsvvOD0wHSAn9L3nrlnrRflInt08YTNniaeNA1Irm4Ob5x6bHk9ElVJM75-Dg8c5aG4ZQKpc5HivMmgEUmoOhW0HStDDGZr5ZJxkDgpS8OZOUcRlN207-4UqyqSRSUp8tVcwoVsIhbJrEhXJyUP7Z6QNGJvHgCS4-wSnryIZBlxkiGi9BQE0_1Uu--TvGw1fvv8yYyvjl972jd5NUqqG8Twym5Wpwp9fpnqyHV87GG8fR6_4ryiwZI_9lOi2-4AOp0ie-b1uDc93jx_CIbyjchw7pJv3mIFnNgoDoPONoTnFAHkSOzUZazYl2_wxQ5xqkpwLW2ImDtHMC76DwJQDedD7ntt8l02tNusbg4CXmYluAOHCixOiRsmnSwKk8g3XjBLJOwO7U2YhWpZByfecMDELKeH36y9GXnS7eugwJhTy3ocnbahMeDdsonl32bKycbNgE6fseD6XLkdf6CdinyvTFWIq_21YPzSzpIfI-Nh2Z8wsNgFi471HXLwhQAyhaaTNf_9j8oy6ubWEoIa5YyEzagHPhUMn0mXIRXNdiVFj5-Lrz9d7m3KO_DBCIRKKBUyBjDV1bIjmjN2Ju7j_oxGqDt9GakDop1EgLVEzC9WiZt8Rc2nytMu_sFFS6Jy8qwU8-zAtbDUsOfLW_2X4NJMwMU08A15Q0wWmPYOthpnydHArcqdvnbKKDvzK3BvdHnEpUzh-_cubYQqutf03-OjGdmrt4Mcp2drcqcrP4AJUgeX4DQPzSu9y0FaY47phqbKTF8xxaSZrZJYHtLda0FBTdU_zRu4oCWlkjEKwuGqyY1DFix8O-MOuSvpwfyrMXU3V3xiwFYjmtYXksNM63ceGco_jyEDeOPPBpCPDY33D1WsKTXujXfv6Y_cilhXLqRYJy2VNtGDZV9-rGpJQJtFGzdt-Ajj9A8wQ1Azj9BAi1f1QxmxneN_S4ekxrNSgHBwaMEHPyi7UMU9TaF5r2Sffz74LeU6z_yejbHcMt9RhJjSGLvunIS4o05zXF0fhadQBzgZRg2jL-8i6oXrbsAGGt3wzCCZJC_xGgWP_mi6AeYYaOh9jBYaCjRTgbkdomVvmxb6PQVJycTQCxV7SwjG0uZZlK4V-KQ_-q6J2r5o6UzjTgWOr66WviiIzeI0yrIJiCIb-T8bZNCkTSRDW9_obHY_6gXK5dEU9pFkNlDDqJFNZc3H0iskkyarkHhn4cIovWDFY2QCcTl_eG_Wk653VpYRB_HM7HqhX4JvYOmDC_ypM_Exac70dz7aWm_Tjr3QA4ERycwPjAIKLpErS8a1jNKf7vwiTNcLAgR7-oGss5usVurbn_hehdcHIPTo8jAka-fxqpy1ylSxAGuSikSWSJ-HfGt1Pmqbg6CX9OQkJUcTc2xddHO_318TlAW67966C0EFV40dylSa0DKpKMMsGgHU6aw1aWhSyIbFemp6Rx9vJFrVHbQzMaZpNzhbQSWgGf9f663lF7M5Fzz-vOaKWSry28v74maw8tNNUwJtS4nG9QAFwIVayBbvftygcEFogO9a6AE8krdNS9fhjn2dP9MELX1WzqhuhOH3-OnpTwaHnnZdO7CYQHOwscwI2YgCm7MEWZwFisywJGZosFgZ6s9GVg3ehEXGKYHQWczuAQNCbZn8QQjxZezvZZxKS22NUoWGtdGDQ_7pBwNtAWk3XuUNVa7QqiffPsLk1sDXhz7kDALQ4XqilASivdxsKmqPKmSXNE-ENtBIWQ7dAXJkQZ0O4GDML_XGp9EzCWintyrfYWEXtKlH5oyF-C-nuG1k4kiJbb8i5hVh6biJ0pCLJVdwk5m8LRbyD9dH_xHvf_FWBe_hn46b68PaLKysbJAGQDg-b5jhz_K13Ri4G_-H5mh_XqY6u8uYcVQMubhUPPcOgumQY3C3gekopq1kPsiHv3IF-GA9TLmj1a8P_sTXBs1LmAyVALYsQDK9LDPxq9DM7p_P74Y-khrCwIe-iNk12vk4LpcLY_Lhw2gOGOEh_7xW1kwOyNNC_PWbCQJIoTivwvainJF5C4BXEDqe5fgcfzRSFVFBokw6fFuW1bek4Wt8J9TJ--nr2Ry1WU8oSnIGjZdLufh4TYvX53XPtXW_pzFq39Rf6Pbo40MwVtnpC1mV03pUT9nIs5qbsgSuYJhms3A6LhZnxQV9KhDT1eiPXRce-E0c3xqv8__uH908J-6e_4Vebh27eo6NhSGicRRSLcTkIT7665Ebu7ks9g-zwfV_aiw8UjqLchilYMRdW6R087LS-Myls3JMqZ_G2qMzoLy82qdqmfp8NL19JVPcFwlNC1_BiU6U88vgRmsK1eUkkmfNvQSi5OiGHXuGMEYEQgNZQoxTPS4wELvSC7jtjSNq-eRszm1pL1QuNnphpkoUyqAMfdJCmDH23OLF2_O6qNyUMyki-UZ_pBDrDcYFNR6l47tvtIaCL3m6dqF0eb5wBTBLXO3W0_xMfDWQyNHNEZ6utAdnU0XJ9UAZfxwfqjb57WgDXUQ6Lb93LlbcKzqDYNEm2zuAAVwkQAVQTjb0haJtCnqZCSDUkz6Q-9lUoAS14uLgLdhpTrKZePM9A1QwhLzidlNFS8RBB8fTZhiHlxychA19ZHhryETFXhFu4XjlBQ1-uk7QP2DEK8fo0ZmTjzllom6fQAucCwTjJ-GFU-dNFaUjDVX75AnxXyIqZxAssG0PRr9PTQMCiheIJwAJ2TYEBy1NG24sxcQm6__ZuwlUfnIm1fQW8Uc6oTIkM8ubEfVXDbynQcXShMySpYPYM6eJZHKNPUcZ9dMvmC-LHbJE7ex3Zs4rNnZa2_kjP-7MCmW7uxtvxln8y0paofo8kd3aooPu8Eo9Cb5p2EGEQ-v4leHS484YnhJnFMC5XtlfQmd5VgzPxMjAALXbJgeWmt6YOrrSmsgVPdnaFIgetceuCY2D2tthPnEEDPG6HlCYdGkEqNa9KnToG1fLHDB8KrorX78iXq945UiFZ5ZEpJ8i-yV61j9jjnFQwwwcGUxSEyV0MZuNDQ98-XY2OxIyBf4jxRZQe2TKYUScUDMQlkrvK2r90cH4QA4ZLmCo0ovwET63o7UxBRyn96aDF-w==

# В переменной my_df сохранен dataframe с произвольным числом количественных переменных. При помощи функции apply найдите максимальное значение в каждой строке. Сохраните результат (вектор максимальных значений) в переменную row_max.

row_max <- apply(my_df, MARGIN = 1, FUN = max)

# В переменной my_df сохранен dataframe с произвольным числом количественных переменных. Рассчитайте медиану для всех столбцов с количественными переменными. В переменную col_median сохраните вектор полученных значений. 

col_median <- apply(my_df, MARGIN = 2, FUN = median)

# Напишите функцию get_negative_values, которая получает на вход dataframe произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта переменная нас не интересует, для всех переменных, в которых есть отрицательные значения мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой переменной (смотри пример работы функции).

get_negative_values <- function(df){
    Filter(length, apply(df, 2, function(x) subset(x, x < 0)))
}

# Напишите функцию na_rm которая заменяет все пропущенные значения в столбцах dataframe на соответствующее среднее значение.

na_rm  <- function(test_data){
as.data.frame(apply(test_data, 2, function(x) ifelse(is.na(x), mean(x, na.rm = TRUE), x)))
}

# Основная задача функции - найти сумму положительных значений в каждой переменной и сохранить их в список.

positive_sum <-  function(d){
    lapply(d, FUN = function(x) sum(subset(x, x > 0)))
}

# Напишите функцию my_names, которая получает на вход  датафрейм и вектор с именами тех генов, для которых мы хотим отобрать наблюдения уровня экспрессии.

my_names <- function (dataset, names) {
    dataset[sapply(names, grep, dataset$name), ]
}

# Итак, ваша задача — создать в данных новую числовую переменную is_outlier, которая будет принимать значение 1, если наблюдение в этой строке является выбросом в своей группе, и 0, если не является.

find_outliers <- function(t){
  f <- names(which(sapply(t, is.factor)))
  t %>% 
    group_by_(.dots = f) %>% 
    mutate_each(funs(is_outlier = as.numeric( abs(. - mean(.)) >  2*sd(.) )))
}

# Мы хотим построить линейную регрессию для предсказания значений зависимой переменной, однако, в качестве предикторов мы хотим использовать только те переменные, распределение которых значимо не отличается от нормального (p - value теста Шапиро - Уилка больше 0.05).
# Напишите функцию smart_lm, которая получает на вход data.frame с произвольным числом количественных переменных. Первая колонка в данных - это зависимая переменная, все остальные - предикторы. На первом этапе вы должны отобрать предикторы для модели.
# Функция возвращает в виде вектора коэффициенты линейной регрессии построенной только для отобранных предикторов (условие нормальности распределения). Если таких предикторов в данных не оказалось, то функция возвращает предупреждение "There are no normal variables in the data".

smart_lm <- function(df){
    is.normal <- sapply(df[-1], function(x) shapiro.test(x)$p > 0.05)
    if (sum(is.normal) > 0) {
      lm(df[c(T, is.normal)])$coeff
    } else {
      "There are no normal variables in the data"
    }
}

# В этой задаче мы используем выборочный t - test, который сравнивает выборочное среднее с предполагаемым средним в генеральной совокупности. 
# Напишите функцию one_sample_t, которая получает на вход два аргумента:
# 1. Dataframe произвольного размера с произвольным числом переменных различного типа.
# 2. Числовое значение среднего в генеральной совокупности.
# Ваша функция должна применять одновыборочный t - test к каждой числовой переменной в данных, и сравнивать среднее значение этой переменной с указанным значением среднего в генеральной совокупности (второй аргумент функции).
# Функция должна возвращать список, где каждый элемент это вектор, состоящий из t - значения, числа степеней свобод (df) и значения p - value.

one_sample_t <- function(test_data, general_mean){
    num <- sapply(test_data, is.numeric)
    result <- lapply(test_data[num], function (x) c(t.test(x,mu=general_mean)$statistic,                                                                           t.test(x,mu=general_mean)$parameter,
                                                    t.test(x,mu=general_mean)$p.value))
}

# Итак, ваша задача, написать функцию get_p_value, которая получает на вход список (назовем его главным списком), каждый элемент этого списка тоже список - результат выполнения функции shapiro.test (смотри пример normality_tests). Ваша задача из каждого элемента главного списка вытащить только p - value. В итоге функция возвращает список где каждый элемент - одно значение - p - value (как в примере normality_tests_p).

get_p_value <- function(test_list){
    normality_test <- lapply(test_list, function (x) x$p.value)
}

# В переменную d сохраните только нeчетные строчки исходных данных diamonds.

d <-diamonds[seq(1,nrow(diamonds), 2), ]

# Из данных mtcars отберите только четыре переменные: mpg, hp, am, vs. Оставьте только те наблюдения, для которых значения mpg > 14 и hp > 100. Отсортируйте получившиеся данные по убыванию переменной mpg и возьмите только первые 10 строчек. Переменную mpg переименуйте в Miles per gallon, а переменную hp в  Gross horsepower (обратите внимание, dplyr позволит нам создать пременные с пробелами в названии).

my_df <- mtcars %>% 
  select(mpg, hp, am, vs) %>% 
  filter( mpg > 14,  hp > 100) %>% 
  arrange(desc(mpg)) %>% 
  slice(1:10) %>% 
  rename("Miles per gallon" = mpg, "Gross horsepower" = hp)

# Напишите функцию, all_to_factor, которая преобразует dataframe, переводя все его переменные в фактор.

all_to_factor <- function(x){
    mutate_each(x, funs(factor))
}

# На первом этапе функция должна выполнить предобработку числовых переменных. Т.к. значение логарифма мы можем рассчитать только для положительных чисел. Для этого сделаем центрирование всех переменных (Rescaling), только еще добавим единичку, чтобы у нас не осталось нулей. После того как мы масштабировали каждую переменную, осталось рассчитать значение натурального логарифма каждого наблюдения (функция log) и вернуть новый dataframe.

log_transform <- function(df){
  res <- df %>% mutate_if(is.numeric, function (x) log(1 + (x - range(x)[1]) / (range(x)[2] - range(x)[1])))
}

# Функция должна возвращать dataframe с описательными статистиками и количеством NA, рассчитанными в каждой группе: количеств наблюдений,﻿ среднее значение, стандартное отклонение, медиана, первый квартиль, третий квартиль, число пропущенных значений.

descriptive_stats <- function (df){
  res <- df %>% 
        group_by(.dots = names(which(sapply(df, is.factor)))) %>% 
        summarise_if(is.numeric, funs(n = n(),
                                      mean = mean(., na.rm = T), 
                                      sd = sd(., na.rm = T), 
                                      median = median(., na.rm = T), 
                                      first_quartile = quantile(., 0.25, na.rm = T), 
                                      third_quartile = quantile(., 0.75, na.rm = T),
                                      na_values = sum(is.na(.))
                                      )
                     )
}

# Напишите функцию, to_factors, которая получает на вход dataframe  с произвольным числом количественных переменных и вектор с номерами колонок, которые нужно перевести в фактор.
# Для перевода числовых колонок в фактор будем использовать следующий принцип, если наблюдение больше среднего всей переменной то 1, иначе 0.

to_factors <- function(df, v){
    df <- mutate_each(df, funs(as.factor(ifelse(. > mean(.), 1, 0))), v)
  }

# Создайте новый dataframe с именем high_price, в котором будут хранится только 10 самых дорогих бриллиантов каждого цвета. Также в итоговом datafrmae должны храниться только две переменные color и price.

high_price <- diamonds %>% 
              group_by(color) %>% 
              select(color, price) %>% 
              arrange(desc(price)) %>% 
              slice(1:10)

# Напишите функцию filter.expensive.available, которая принимает на вход products (объект типа data.table) и вектор названий брендов, и возвращает только те строчки, которые соответствуют товарам, цена которых больше или равна 5000 рублей, доступны на складе, и принадлежат одному из переданных брендов.

filter.expensive.available <- function(products,brands){
  products[brand %in% brands & available==TRUE & price>=5000*100]
}

# Создайте функцию ordered.short.purchase.data, которая будет принимать purchases, объект data.table, и возвращать таблицу только со столбцами с номером заказа и ID продукта.
# Упорядочите результат по убыванию стоимости купленного товара. Возвраты (записи с отрицательным количеством предметов в позиции) надо удалить.

ordered.short.purchase.data <- function(purchases) {
  dt <- purchases[quantity > 0][order(-price), list(ordernumber, product_id)]
}

# Напишите функцию purchases.median.order.price, у которой один аргумент: purchases, и которая возвращает медианную стоимость заказа (число).
# Группировку стоит проводить с помощью data.table. Записи с неположительным количеством купленных товаров (возвраты) игнорировать.
# Обратите внимание, что одному заказу может соответствовать несколько записей – «позиций» с одинаковым ordernumber, и что при расчете стоимости заказа надо учитывать ситуации, когда пользователь купил несколько товаров одного типа (их количество указано в quantity).

purchases.median.order.price <- function(dt){
  dt[quantity > 0][, .(price = sum(price*quantity)), by = ordernumber][, median(price)]
}

# Создайте функцию get.category.ratings, которая будет возвращать суммарный оборот (с учетом скидок) каждой категории , и количество купленных предметов по таблице покупок и таблице принадлежности товара к категории. Если купленный товар принадлежит нескольким категориям, его необходимо учитывать во всех. При решении используйте ключи.

get.category.ratings <- function(purchases, products) {  
  setkey(purchases, product_id)
  setkey(products, product_id)
  merge(purchases, products, by = "product_id", allow.cartesian = T)[,list(totalcents = sum(totalcents), quantity = sum(quantity)), by = "category_id"]  
}

# Напишите функцию, которая будет с помощью := добавлять столбец «price.portion», содержащий процент стоимости товара в заказе, с двумя знаками после запятой (нули после запятой не опускать). Проверяться будет возвращаемая из функции таблица. Тип нового столбца - character (строка). Записи с неположительным количеством товаров убрать перед расчётом.

mark.position.portion <- function(purchases) {
  res <- purchases[quantity > 0][, "price.portion" := sprintf("%.2f", round(((price * quantity) / sum(price * quantity)) * 100, 6)), by = ordernumber]
}

# Используя функцию qplot, постройте гистограмму переменной depth из данных diamonds.

depth_hist <- qplot(diamonds$depth)

# Постройте диаграмму рассеивания (scatter plot) как в указанном ниже примере, результат сохраните в переменную price_carat_clarity_points.
# данные - diamonds, ось x - carat, ось y - price, цвет точек - clarity.

price_carat_clarity_points <- qplot(x = carat,
                                    y = price,
                                    color = factor(clarity),
                                    data = diamonds)

# Используя функцию qplot, постройте график плотности переменной x из данных diamonds.

x_density <- qplot(x = x,
                   geom = "density",
                   data = diamonds)

# Усложним задачу, постройте график плотности переменной x для каждой группы наблюдений по переменной cut из данных diamonds. Таким образом за цвет графика теперь отвечает переменная cut. Сохраните результат в переменную x_cut_density.

x_cut_density <- qplot(x = x,
                       color = factor(cut),
                       geom = "density",
                       data = diamonds)

# Давайте построим график violin plot для переменной price в каждой группе наблюдений по переменной color.

price_violin <- qplot(x = color,
                      y = price,
                      geom = "violin",
                      data = diamonds)

# Используя данные mtcars скомбинируем два варианта отображения количественных данных boxplot и violin plot: ось x - am (нужен фактор), ось y - mpg. 

my_plot <- ggplot(mtcars, aes(x = factor(am), y = mpg)) +
  geom_violin() + 
  geom_boxplot(width = 0.2)

# Отобразите взаимосвязь между доходом (income) и числом продаж (sale), цветом точек указав номер магазина (shop).

my_plot <- ggplot(sales, aes(x = income, y = sale)) +
  geom_point(aes(color = shop)) +
  geom_smooth()

# При помощи функции stat_summary постройте график с доверительными интервалами для демонстрации различий в доходах двух магазинов с учетом времени года: переменная shop - ось x, переменная income - ось y, переменная season - цвет, geom pointrange.

my_plot <- ggplot(sales, aes(x = shop, y = income, col = season)) +
  stat_summary(fun.data = mean_cl_boot, position = position_dodge(0.2))

# Теперь давайте отобразим на графике различия в продажах (переменная sale), в зависимости от: года (date) - ось x, номера магазина (shop) - цвет. Дополните предложенный код, чтобы получился график как в примере ниже. Используйте функцию mean_cl_boot для построения доверительных интервалов.Вам также понадобится использовать три geoms: errorbar, point, line. Используйте их прямо внутри функции stat_summary().

my_plot <-  ggplot(sales, aes(date, sale, color = shop))+
  stat_summary(fun.data = mean_cl_boot, geom = "errorbar", width = 0.2, position = position_dodge(0.2)) + 
  stat_summary(fun.data = mean_cl_boot, geom = "point", size = 2, position = position_dodge(0.2)) + 
  stat_summary(fun.data = mean_cl_boot, geom = "line", position = position_dodge(0.2)) 

# Потренируемся с разбиением графика на подгруппы! Используя facet_grid постройте следующий график и сохраните его в переменную mpg_facet: ось x - переменная mpg, facet - переменная am по строчкам и vs по столбцам.

mpg_facet <- ggplot(mtcars, aes(mpg)) +
  geom_dotplot() +
  facet_grid(am ~ vs)

# Используя данные iris, постройте график плотности для переменной Sepal.Length. Разбейте график на части по переменной Species при помощи facet_wrap.

sl_wrap <- ggplot(iris, aes(Sepal.Length))+ 
  geom_density() + 
  facet_wrap( ~ Species)

# Используя данные Iris, постройте график, иллюстрирующий взаимосвязь переменных Sepal.Length и Sepal.Width внутри каждого вида (переменной Species), при помощи facet_wrap(). В этом задании вам потребуется использовать два geom: geom_point - для отображения отдельных наблюдений, geom_smooth - для добавления сглаживания.

my_plot <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + 
  geom_point() + 
  geom_smooth() +
  facet_wrap( ~ Species)

# Давайте построим следующий график, чтобы выяснить есть ли различия в бюджетах фильмов разного жанра из года в год. Cохраните результат в переменную my_plot: ось x - переменная Type, ocь y - переменная Budget, facet - переменная Year (используйте facet_grid).

my_plot <- ggplot(myMovieData, aes(Type, Budget))+ 
  geom_boxplot() + 
  facet_grid(. ~ Year) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

# В этом задании мы построим график используя данные Iris. Наша цель отобразить взаимосвязь переменных Sepal.Length (ось X) и Petal.Length (ось Y) внутри трех групп по переменной Species. Для этого постройте scaterplot, отобразите цветом значения переменной Species и добавьте линейное сглаживание в каждой группе. Далее от вас потребуется привести график к более завершенному виду. 
# Мы переведем на русский название осей, название легенды и ее расшифровку: Ось X - "Длина чашелистика", Ось Y - "Длина лепестка". Название легенды - "Вид цветка". Расшифровка легенды: "Ирис щетинистый", "Ирис разноцветный", "Ирис виргинский". Также мы чуть измени отображение значений по осям. Значения по оси X должны начинаться с 4 и заканчиваться на 8 с шагом в единицу. Значения по оси Y должны начинаться с 1 и заканчиваться на 7 с шагом в единицу.
 
iris_plot <- ggplot(iris, aes(x = Sepal.Length, y = Petal.Length, col = factor(Species))) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_color_discrete(name =  "Вид цветка", 
                       labels = c("Ирис щетинистый", "Ирис разноцветный", "Ирис виргинский")) +
  scale_x_continuous(name = "Длина чашелистика", 
                     breaks = seq(4, 8, 1),
                     limits = c(4, 8)) +
  scale_y_continuous(name = "Длина лепестка", 
                     breaks = seq(1, 7, 1),
                     limits = c(1, 7))
